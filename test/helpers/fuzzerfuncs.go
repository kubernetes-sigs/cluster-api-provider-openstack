/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package helpers

import (
	"strings"

	fuzz "github.com/google/gofuzz"
	"k8s.io/utils/ptr"

	infrav1 "sigs.k8s.io/cluster-api-provider-openstack/api/v1beta1"
	"sigs.k8s.io/cluster-api-provider-openstack/pkg/utils/optional"
)

func filterInvalidTags(tags []infrav1.NeutronTag) []infrav1.NeutronTag {
	var ret []infrav1.NeutronTag
	for i := range tags {
		s := string(tags[i])
		if len(s) > 0 && !strings.Contains(s, ",") {
			ret = append(ret, tags[i])
		}
	}
	return ret
}

func nonEmptyString(c fuzz.Continue) string {
	for {
		if s := c.RandString(); s != "" {
			return s
		}
	}
}

type isZeroer[T any] interface {
	IsZero() bool
	*T
}

func fuzzFilterParam[Z isZeroer[T], T any](id *optional.String, filter *Z, c fuzz.Continue) {
	if c.RandBool() {
		*id = ptr.To(nonEmptyString(c))
		*filter = nil
	} else {
		*filter = new(T)
		for (*filter).IsZero() {
			c.Fuzz(*filter)
		}
		*id = nil
	}
}

// InfraV1FuzzerFuncs returns fuzzer funcs for v1beta1 OpenStack types which:
// * Constrain the output in ways which are validated by the API server
// * Add additional test coverage where it is not generated by the default fuzzer.
func InfraV1FuzzerFuncs() []interface{} {
	return []interface{}{
		func(spec *infrav1.OpenStackClusterSpec, c fuzz.Continue) {
			c.FuzzNoCustom(spec)

			// The fuzzer only seems to generate Subnets of
			// length 1, but we need to also test length 2.
			// Ensure it is occasionally generated.
			if len(spec.Subnets) == 1 && c.RandBool() {
				subnet := infrav1.SubnetParam{}
				c.Fuzz(&subnet)
				spec.Subnets = append(spec.Subnets, subnet)
			}
		},

		func(spec *infrav1.SubnetSpec, c fuzz.Continue) {
			c.FuzzNoCustom(spec)

			// CIDR is required and API validates that it's present, so
			// we force it to always be set.
			for spec.CIDR == "" {
				spec.CIDR = c.RandString()
			}
		},

		func(pool *infrav1.AllocationPool, c fuzz.Continue) {
			c.FuzzNoCustom(pool)

			// Start and End are required properties, let's make sure both are set
			for pool.Start == "" {
				pool.Start = c.RandString()
			}

			for pool.End == "" {
				pool.End = c.RandString()
			}
		},

		// v1beta1 filter tags cannot contain commas and can't be empty.
		func(filter *infrav1.FilterByNeutronTags, c fuzz.Continue) {
			c.FuzzNoCustom(filter)

			// Sometimes add an additional tag to ensure we get test coverage of multiple tags
			if c.RandBool() {
				filter.Tags = append(filter.Tags, infrav1.NeutronTag(c.RandString()))
			}
			if c.RandBool() {
				filter.TagsAny = append(filter.TagsAny, infrav1.NeutronTag(c.RandString()))
			}
			if c.RandBool() {
				filter.NotTags = append(filter.NotTags, infrav1.NeutronTag(c.RandString()))
			}
			if c.RandBool() {
				filter.NotTagsAny = append(filter.NotTagsAny, infrav1.NeutronTag(c.RandString()))
			}

			// Remove empty tags and tags with commas
			filter.Tags = filterInvalidTags(filter.Tags)
			filter.TagsAny = filterInvalidTags(filter.TagsAny)
			filter.NotTags = filterInvalidTags(filter.NotTags)
			filter.NotTagsAny = filterInvalidTags(filter.NotTagsAny)
		},

		// v1beta1 filter params contain exactly one of ID or filter
		func(param *infrav1.NetworkParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		func(param *infrav1.SubnetParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		func(param *infrav1.SecurityGroupParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		func(param *infrav1.ImageParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		func(param *infrav1.RouterParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		func(param *infrav1.SecurityGroupParam, c fuzz.Continue) {
			fuzzFilterParam(&param.ID, &param.Filter, c)
		},

		// Ensure VolumeAZ type is valid
		func(az *infrav1.VolumeAvailabilityZone, c fuzz.Continue) {
			stringWithoutSpaces := func() string {
				for {
					s := c.RandString()
					if !strings.Contains(s, " ") && len(s) > 0 {
						return s
					}
				}
			}

			// From is defaulted
			if c.RandBool() {
				name := infrav1.VolumeAZName(stringWithoutSpaces())
				az.Name = &name
				return
			}

			// From is Name
			if c.RandBool() {
				az.From = infrav1.VolumeAZFromName
				name := infrav1.VolumeAZName(stringWithoutSpaces())
				az.Name = &name
				return
			}

			// From is Machine
			az.From = infrav1.VolumeAZFromMachine
		},
	}
}
